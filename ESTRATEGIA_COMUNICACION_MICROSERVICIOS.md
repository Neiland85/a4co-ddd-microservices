# üîÑ ESTRATEGIA DE COMUNICACI√ìN ENTRE MICROSERVICIOS

**Proyecto:** A4CO DDD Microservices - Marketplace Local de Ja√©n  
**Fecha:** Julio 2025  
**Enfoque:** Event-Driven Architecture + Domain-Driven Design

---

## üéØ RESUMEN EJECUTIVO

Esta estrategia define la comunicaci√≥n entre los 15+ microservicios del marketplace, estableciendo patrones claros para
interacciones s√≠ncronas (REST) y as√≠ncronas (eventos), garantizando bajo acoplamiento y alta cohesi√≥n.

### Principios de Comunicaci√≥n

- **As√≠ncrono por defecto**: Los eventos de dominio son la forma principal de comunicaci√≥n
- **S√≠ncrono cuando sea necesario**: REST APIs solo para consultas inmediatas y operaciones cr√≠ticas
- **Eventual consistency**: Aceptamos consistencia eventual entre agregados
- **Idempotencia**: Todos los mensajes/eventos deben ser idempotentes

---

## üèóÔ∏è ARQUITECTURA DE COMUNICACI√ìN

### Message Bus Recomendado: **NATS**

**Justificaci√≥n para NATS:**

- üöÄ **Rendimiento**: Ultra-alta velocidad (millones de mensajes/segundo)
- üîÑ **Patrones**: Pub/Sub, Request/Reply, Queue Groups
- üì° **Features**: Stream persistence, JetStream para durabilidad
- üê≥ **Deployment**: Lightweight, ideal para contenedores
- üîß **Operaci√≥n**: Configuraci√≥n m√≠nima, clustering autom√°tico

### Configuraci√≥n NATS

```yaml
# docker-compose.yml
services:
  nats:
    image: nats:latest
    command: [
        "-js", # JetStream enable
        "-sd",
        "/data", # Stream directory
        "-m",
        "8222", # Monitoring port
      ]
    ports:
      - "4222:4222" # Client connections
      - "8222:8222" # HTTP monitoring
    volumes:
      - nats_data:/data

  nats-box:
    image: natsio/nats-box:latest
    depends_on: [nats]
```

---

## üîÑ MATRIZ DE COMUNICACI√ìN

### Comunicaci√≥n S√çNCRONA (REST APIs)

| Servicio Origen     | Servicio Destino      | Endpoint                                  | Prop√≥sito                  | Justificaci√≥n                             |
| ------------------- | --------------------- | ----------------------------------------- | -------------------------- | ----------------------------------------- |
| **order-service**   | **inventory-service** | `GET /api/inventory/check/{productId}`    | Verificar stock disponible | Validaci√≥n inmediata antes de crear orden |
| **order-service**   | **payment-service**   | `POST /api/payments/validate`             | Validar m√©todo de pago     | Validaci√≥n cr√≠tica en tiempo real         |
| **payment-service** | **user-service**      | `GET /api/users/{userId}/payment-methods` | Obtener m√©todos de pago    | Datos requeridos para procesamiento       |
| **dashboard-web**   | **product-service**   | `GET /api/products/search`                | B√∫squeda de productos      | UI requiere respuesta inmediata           |
| **dashboard-web**   | **user-service**      | `GET /api/users/profile`                  | Datos del perfil           | Informaci√≥n de sesi√≥n cr√≠tica             |
| **geo-service**     | **artisan-service**   | `GET /api/artisans/nearby`                | Productores cercanos       | Consulta geogr√°fica en tiempo real        |
| **admin-service**   | **analytics-service** | `GET /api/analytics/dashboard`            | M√©tricas en tiempo real    | Dashboard administrativo                  |
| **auth-service**    | **user-service**      | `POST /api/users/validate-token`          | Validar autenticaci√≥n      | Seguridad cr√≠tica                         |

### Comunicaci√≥n AS√çNCRONA (Eventos de Dominio)

#### 1. Order Domain Events

```typescript
// Eventos publicados por order-service
export class OrderCreatedEvent extends DomainEvent {
  constructor(
    orderId: string,
    data: {
      customerId: string;
      items: OrderItem[];
      totalAmount: number;
      deliveryAddress: Address;
      createdAt: Date;
    }
  ) {
    super(orderId, data);
  }
}

export class OrderConfirmedEvent extends DomainEvent {
  constructor(
    orderId: string,
    data: {
      confirmedAt: Date;
      estimatedDelivery: Date;
      paymentReference: string;
    }
  ) {
    super(orderId, data);
  }
}

export class OrderCancelledEvent extends DomainEvent {
  constructor(
    orderId: string,
    data: {
      reason: string;
      cancelledAt: Date;
      refundRequired: boolean;
    }
  ) {
    super(orderId, data);
  }
}

export class OrderDeliveredEvent extends DomainEvent {
  constructor(
    orderId: string,
    data: {
      deliveredAt: Date;
      deliveryConfirmation: string;
      recipientSignature?: string;
    }
  ) {
    super(orderId, data);
  }
}
```

**Suscriptores:**

- `OrderCreatedEvent` ‚Üí `inventory-service`, `payment-service`, `notification-service`, `analytics-service`
- `OrderConfirmedEvent` ‚Üí `notification-service`, `loyalty-service`, `artisan-service`
- `OrderCancelledEvent` ‚Üí `inventory-service`, `payment-service`, `notification-service`
- `OrderDeliveredEvent` ‚Üí `loyalty-service`, `analytics-service`, `notification-service`

#### 2. Inventory Domain Events

```typescript
// Eventos publicados por inventory-service
export class StockReservedEvent extends DomainEvent {
  constructor(
    productId: string,
    data: {
      orderId: string;
      quantityReserved: number;
      remainingStock: number;
      reservationExpiry: Date;
    }
  ) {
    super(productId, data);
  }
}

export class StockReleasedEvent extends DomainEvent {
  constructor(
    productId: string,
    data: {
      orderId: string;
      quantityReleased: number;
      reason: "order-cancelled" | "reservation-expired" | "payment-failed";
      newStock: number;
    }
  ) {
    super(productId, data);
  }
}

export class LowStockWarningEvent extends DomainEvent {
  constructor(
    productId: string,
    data: {
      currentStock: number;
      threshold: number;
      artisanId: string;
      productName: string;
    }
  ) {
    super(productId, data);
  }
}

export class StockUpdatedEvent extends DomainEvent {
  constructor(
    productId: string,
    data: {
      previousStock: number;
      newStock: number;
      updateReason: string;
      updatedBy: string;
    }
  ) {
    super(productId, data);
  }
}
```

**Suscriptores:**

- `StockReservedEvent` ‚Üí `order-service`, `notification-service`
- `StockReleasedEvent` ‚Üí `order-service`, `product-service`
- `LowStockWarningEvent` ‚Üí `artisan-service`, `notification-service`
- `StockUpdatedEvent` ‚Üí `product-service`, `analytics-service`

#### 3. Payment Domain Events

```typescript
// Eventos publicados por payment-service
export class PaymentInitiatedEvent extends DomainEvent {
  constructor(
    paymentId: string,
    data: {
      orderId: string;
      amount: number;
      currency: string;
      paymentMethod: string;
      customerId: string;
    }
  ) {
    super(paymentId, data);
  }
}

export class PaymentSucceededEvent extends DomainEvent {
  constructor(
    paymentId: string,
    data: {
      orderId: string;
      transactionId: string;
      amount: number;
      processedAt: Date;
      paymentGateway: string;
    }
  ) {
    super(paymentId, data);
  }
}

export class PaymentFailedEvent extends DomainEvent {
  constructor(
    paymentId: string,
    data: {
      orderId: string;
      errorCode: string;
      errorMessage: string;
      retryable: boolean;
      failedAt: Date;
    }
  ) {
    super(paymentId, data);
  }
}

export class RefundProcessedEvent extends DomainEvent {
  constructor(
    refundId: string,
    data: {
      originalPaymentId: string;
      orderId: string;
      amount: number;
      reason: string;
      processedAt: Date;
    }
  ) {
    super(refundId, data);
  }
}
```

**Suscriptores:**

- `PaymentInitiatedEvent` ‚Üí `order-service`, `analytics-service`
- `PaymentSucceededEvent` ‚Üí `order-service`, `loyalty-service`, `notification-service`
- `PaymentFailedEvent` ‚Üí `order-service`, `inventory-service`, `notification-service`
- `RefundProcessedEvent` ‚Üí `order-service`, `notification-service`, `analytics-service`

#### 4. User Domain Events

```typescript
// Eventos publicados por user-service
export class UserRegisteredEvent extends DomainEvent {
  constructor(
    userId: string,
    data: {
      email: string;
      firstName: string;
      lastName: string;
      registrationDate: Date;
      preferredLanguage: string;
      location?: Address;
    }
  ) {
    super(userId, data);
  }
}

export class UserProfileUpdatedEvent extends DomainEvent {
  constructor(
    userId: string,
    data: {
      changedFields: string[];
      previousValues: Record<string, any>;
      newValues: Record<string, any>;
      updatedAt: Date;
    }
  ) {
    super(userId, data);
  }
}

export class UserPreferencesChangedEvent extends DomainEvent {
  constructor(
    userId: string,
    data: {
      preferences: {
        notifications: boolean;
        newsletter: boolean;
        productCategories: string[];
        deliveryRadius: number;
      };
      updatedAt: Date;
    }
  ) {
    super(userId, data);
  }
}
```

**Suscriptores:**

- `UserRegisteredEvent` ‚Üí `notification-service`, `loyalty-service`, `analytics-service`
- `UserProfileUpdatedEvent` ‚Üí `notification-service`, `geo-service`
- `UserPreferencesChangedEvent` ‚Üí `notification-service`, `product-service`

#### 5. Artisan Domain Events

```typescript
// Eventos publicados por artisan-service
export class ArtisanVerifiedEvent extends DomainEvent {
  constructor(
    artisanId: string,
    data: {
      businessName: string;
      contactEmail: string;
      location: Address;
      specialties: string[];
      verifiedAt: Date;
      verifiedBy: string;
    }
  ) {
    super(artisanId, data);
  }
}

export class NewProductListedEvent extends DomainEvent {
  constructor(
    productId: string,
    data: {
      artisanId: string;
      productName: string;
      category: string;
      price: number;
      initialStock: number;
      listedAt: Date;
    }
  ) {
    super(productId, data);
  }
}

export class ArtisanStatusChangedEvent extends DomainEvent {
  constructor(
    artisanId: string,
    data: {
      previousStatus: string;
      newStatus: string;
      reason: string;
      changedAt: Date;
    }
  ) {
    super(artisanId, data);
  }
}
```

**Suscriptores:**

- `ArtisanVerifiedEvent` ‚Üí `notification-service`, `product-service`, `geo-service`
- `NewProductListedEvent` ‚Üí `product-service`, `inventory-service`, `notification-service`
- `ArtisanStatusChangedEvent` ‚Üí `product-service`, `notification-service`

---

## üì® IMPLEMENTACI√ìN DEL MESSAGE BUS

### Estructura de Eventos en NATS

```typescript
// packages/shared-utils/src/events/event-bus.ts
import { connect, NatsConnection, Codec, StringCodec } from "nats";
import { DomainEvent } from "../domain/domain-event";

export interface IEventBus {
  publish(subject: string, event: DomainEvent): Promise<void>;
  subscribe(subject: string, handler: (event: DomainEvent) => Promise<void>): Promise<void>;
  subscribeQueue(subject: string, queue: string, handler: (event: DomainEvent) => Promise<void>): Promise<void>;
}

export class NatsEventBus implements IEventBus {
  private nc!: NatsConnection;
  private codec: Codec<string> = StringCodec();

  async connect(servers = ["nats://localhost:4222"]): Promise<void> {
    this.nc = await connect({ servers });
  }

  async publish(subject: string, event: DomainEvent): Promise<void> {
    const eventData = JSON.stringify({
      ...event,
      metadata: {
        publishedAt: new Date().toISOString(),
        version: "1.0",
      },
    });

    this.nc.publish(subject, this.codec.encode(eventData));
  }

  async subscribe(subject: string, handler: (event: DomainEvent) => Promise<void>): Promise<void> {
    const sub = this.nc.subscribe(subject);

    for await (const msg of sub) {
      try {
        const eventData = JSON.parse(this.codec.decode(msg.data));
        await handler(eventData);
      } catch (error) {
        console.error(`Error processing event on ${subject}:`, error);
        // Implement retry logic or dead letter queue
      }
    }
  }

  async subscribeQueue(subject: string, queue: string, handler: (event: DomainEvent) => Promise<void>): Promise<void> {
    const sub = this.nc.subscribe(subject, { queue });

    for await (const msg of sub) {
      try {
        const eventData = JSON.parse(this.codec.decode(msg.data));
        await handler(eventData);
      } catch (error) {
        console.error(`Error processing event on ${subject}:`, error);
      }
    }
  }
}
```

### Subjects/Topics para NATS

```typescript
// packages/shared-utils/src/events/subjects.ts
export const EventSubjects = {
  // Order Events
  ORDER_CREATED: "order.created",
  ORDER_CONFIRMED: "order.confirmed",
  ORDER_CANCELLED: "order.cancelled",
  ORDER_DELIVERED: "order.delivered",

  // Inventory Events
  STOCK_RESERVED: "inventory.stock.reserved",
  STOCK_RELEASED: "inventory.stock.released",
  LOW_STOCK_WARNING: "inventory.stock.low",
  STOCK_UPDATED: "inventory.stock.updated",

  // Payment Events
  PAYMENT_INITIATED: "payment.initiated",
  PAYMENT_SUCCEEDED: "payment.succeeded",
  PAYMENT_FAILED: "payment.failed",
  REFUND_PROCESSED: "payment.refund.processed",

  // User Events
  USER_REGISTERED: "user.registered",
  USER_PROFILE_UPDATED: "user.profile.updated",
  USER_PREFERENCES_CHANGED: "user.preferences.changed",

  // Artisan Events
  ARTISAN_VERIFIED: "artisan.verified",
  NEW_PRODUCT_LISTED: "artisan.product.listed",
  ARTISAN_STATUS_CHANGED: "artisan.status.changed",

  // Notification Events
  NOTIFICATION_SENT: "notification.sent",
  EMAIL_DELIVERED: "notification.email.delivered",
  SMS_DELIVERED: "notification.sms.delivered",
} as const;
```

---

## üîÑ PATRONES DE COMUNICACI√ìN

### 1. Saga Pattern para Transacciones Distribuidas

**Ejemplo: Proceso de Creaci√≥n de Pedido**

```typescript
// order-service/src/sagas/order-creation-saga.ts
export class OrderCreationSaga {
  private eventBus: IEventBus;

  async handleOrderCreated(event: OrderCreatedEvent): Promise<void> {
    try {
      // Paso 1: Reservar stock
      await this.eventBus.publish(
        EventSubjects.STOCK_RESERVED,
        new ReserveStockCommand(event.aggregateId, event.eventData.items)
      );

      // Paso 2: Procesar pago (despu√©s de confirmaci√≥n de stock)
      // Esto se manejar√° en el handler de StockReservedEvent
    } catch (error) {
      // Compensating transaction
      await this.eventBus.publish(
        EventSubjects.ORDER_CANCELLED,
        new OrderCancelledEvent(event.aggregateId, {
          reason: "saga-failure",
          cancelledAt: new Date(),
          refundRequired: false,
        })
      );
    }
  }

  async handleStockReserved(event: StockReservedEvent): Promise<void> {
    // Continuar con el proceso de pago
    await this.eventBus.publish(EventSubjects.PAYMENT_INITIATED, new InitiatePaymentCommand(event.eventData.orderId));
  }

  async handlePaymentSucceeded(event: PaymentSucceededEvent): Promise<void> {
    // Confirmar la orden
    await this.eventBus.publish(
      EventSubjects.ORDER_CONFIRMED,
      new OrderConfirmedEvent(event.eventData.orderId, {
        confirmedAt: new Date(),
        estimatedDelivery: this.calculateDeliveryDate(),
        paymentReference: event.eventData.transactionId,
      })
    );
  }
}
```

### 2. Event Sourcing Pattern (Opcional)

```typescript
// packages/shared-utils/src/event-store/event-store.ts
export interface IEventStore {
  saveEvents(aggregateId: string, events: DomainEvent[], expectedVersion: number): Promise<void>;
  getEvents(aggregateId: string, fromVersion?: number): Promise<DomainEvent[]>;
  getAllEvents(fromPosition?: number): Promise<DomainEvent[]>;
}

export class NatsEventStore implements IEventStore {
  // Implementation using NATS JetStream for persistence
  // Permite replay de eventos y reconstrucci√≥n de estado
}
```

---

## üö¶ CONFIGURACI√ìN POR MICROSERVICIO

### Order Service

```typescript
// apps/order-service/src/events/handlers.ts
export class OrderEventHandlers {
  @EventHandler(EventSubjects.STOCK_RESERVED)
  async onStockReserved(event: StockReservedEvent): Promise<void> {
    // Actualizar estado interno de la orden
    // Continuar con el saga de creaci√≥n
  }

  @EventHandler(EventSubjects.PAYMENT_SUCCEEDED)
  async onPaymentSucceeded(event: PaymentSucceededEvent): Promise<void> {
    // Confirmar la orden
    // Publicar OrderConfirmedEvent
  }

  @EventHandler(EventSubjects.PAYMENT_FAILED)
  async onPaymentFailed(event: PaymentFailedEvent): Promise<void> {
    // Cancelar orden
    // Liberar stock reservado
  }
}
```

### Inventory Service

```typescript
// apps/inventory-service/src/events/handlers.ts
export class InventoryEventHandlers {
  @EventHandler(EventSubjects.ORDER_CREATED)
  async onOrderCreated(event: OrderCreatedEvent): Promise<void> {
    // Intentar reservar stock para todos los items
    // Publicar StockReservedEvent o StockNotAvailableEvent
  }

  @EventHandler(EventSubjects.ORDER_CANCELLED)
  async onOrderCancelled(event: OrderCancelledEvent): Promise<void> {
    // Liberar stock reservado
    // Publicar StockReleasedEvent
  }
}
```

### Notification Service

```typescript
// apps/notification-service/src/events/handlers.ts
export class NotificationEventHandlers {
  @EventHandler(EventSubjects.ORDER_CONFIRMED)
  async onOrderConfirmed(event: OrderConfirmedEvent): Promise<void> {
    // Enviar email de confirmaci√≥n al cliente
    // Notificar al artesano sobre nuevo pedido
  }

  @EventHandler(EventSubjects.LOW_STOCK_WARNING)
  async onLowStockWarning(event: LowStockWarningEvent): Promise<void> {
    // Notificar al artesano sobre stock bajo
    // Enviar alerta al dashboard administrativo
  }

  @EventHandler(EventSubjects.USER_REGISTERED)
  async onUserRegistered(event: UserRegisteredEvent): Promise<void> {
    // Enviar email de bienvenida
    // Configurar preferencias por defecto
  }
}
```

---

## üìä M√âTRICAS Y MONITOREO

### Observabilidad de Eventos

```typescript
// packages/observability/src/event-metrics.ts
export class EventMetrics {
  // M√©tricas de eventos publicados/consumidos
  // Latencia de procesamiento
  // Eventos fallidos
  // Dead letter queue metrics

  trackEventPublished(subject: string, eventType: string): void {
    // Increment counter
  }

  trackEventProcessed(subject: string, eventType: string, duration: number): void {
    // Track processing time
  }

  trackEventFailed(subject: string, eventType: string, error: Error): void {
    // Track failures for alerting
  }
}
```

### Dashboard de Monitoreo

- **NATS Monitoring**: http://localhost:8222
- **M√©tricas de eventos**: Prometheus + Grafana
- **Tracing distribuido**: Jaeger para seguimiento end-to-end
- **Logs estructurados**: ELK stack para an√°lisis

---

## üîí SEGURIDAD Y CONFIABILIDAD

### Autenticaci√≥n de Servicios

```typescript
// packages/shared-utils/src/auth/service-auth.ts
export class ServiceAuth {
  // JWT para autenticaci√≥n entre servicios
  // Certificates para comunicaci√≥n segura
  // Rate limiting por servicio
}
```

### Retry Policies

```typescript
// packages/shared-utils/src/resilience/retry-policy.ts
export class RetryPolicy {
  // Exponential backoff
  // Circuit breaker pattern
  // Dead letter queue para mensajes fallidos
}
```

### Idempotencia

```typescript
// Cada evento debe incluir:
interface EventMetadata {
  eventId: string; // UUID √∫nico
  correlationId: string; // Para tracing
  causationId?: string; // Evento que caus√≥ este evento
  retryCount?: number; // N√∫mero de reintentos
}
```

---

## üöÄ IMPLEMENTACI√ìN RECOMENDADA

### Fase 1: Infraestructura Base (1-2 semanas)

1. ‚úÖ Configurar NATS con JetStream
2. ‚úÖ Implementar EventBus base en shared-utils
3. ‚úÖ Crear clases base de eventos de dominio
4. ‚úÖ Configurar monitoreo b√°sico

### Fase 2: Eventos Cr√≠ticos (2-3 semanas)

1. ‚úÖ Implementar eventos de Order ‚Üí Payment ‚Üí Inventory
2. ‚úÖ Configurar Saga de creaci√≥n de pedidos
3. ‚úÖ Implementar handlers b√°sicos en cada servicio
4. ‚úÖ Testing de flujo completo

### Fase 3: Eventos Secundarios (1-2 semanas)

1. ‚úÖ User events y notificaciones
2. ‚úÖ Artisan events y gesti√≥n de productos
3. ‚úÖ Analytics y m√©tricas
4. ‚úÖ Geolocalizaci√≥n y eventos de ubicaci√≥n

### Fase 4: Optimizaci√≥n y Producci√≥n (1-2 semanas)

1. ‚úÖ Event sourcing (opcional)
2. ‚úÖ Dead letter queues
3. ‚úÖ M√©tricas avanzadas y alertas
4. ‚úÖ Documentaci√≥n y runbooks

---

## üìù CONCLUSIONES

Esta estrategia establece:

### ‚úÖ **Comunicaci√≥n Clara**

- **S√≠ncrona**: Solo para validaciones cr√≠ticas y consultas inmediatas (8 casos)
- **As√≠ncrona**: Para eventos de dominio y coordinaci√≥n (20+ eventos)

### ‚úÖ **Tecnolog√≠a Robusta**

- **NATS**: Message bus moderno y performante
- **Event Sourcing**: Opcional para auditor√≠a completa
- **Saga Pattern**: Para transacciones distribuidas

### ‚úÖ **Observabilidad Completa**

- M√©tricas de rendimiento
- Tracing distribuido
- Alertas proactivas

### ‚úÖ **Escalabilidad**

- Patr√≥n pub/sub para desacoplar servicios
- Queue groups para distribuci√≥n de carga
- Eventual consistency para mejor rendimiento

**El proyecto est√° preparado para manejar el crecimiento del marketplace local de Ja√©n con una arquitectura robusta y
escalable.**
