import { Money, Product } from '../../domain/entities/product.entity';
import { EventSubjects, IEventBus } from '../../domain/event-bus';
import { IProductRepository } from '../../infrastructure/repositories/product.repository';

// ========================================
// DTOs (Data Transfer Objects)
// ========================================

export interface CreateProductDTO {
  name: string;
  description: string;
  sku?: string;
  price: number;
  originalPrice?: number;
  currency?: string;
  artisanId: string;
  categoryId: string;
  category?: string;
  stock?: number;
  slug?: string;
  isHandmade?: boolean;
  isCustomizable?: boolean;
  isDigital?: boolean;
  requiresShipping?: boolean;
  keywords?: string[];
  metaTitle?: string;
  metaDescription?: string;
}

export interface UpdateProductDTO {
  id: string;
  name?: string;
  description?: string;
  price?: number;
  originalPrice?: number;
  category?: string;
  keywords?: string[];
  metaTitle?: string;
  metaDescription?: string;
}

// ========================================
// PRODUCT APPLICATION SERVICE
// ========================================

export class ProductService {
  constructor(
    private readonly productRepository: IProductRepository,
    private readonly eventBus: IEventBus
  ) {}

  async createProduct(dto: CreateProductDTO): Promise<Product> {
    // Check for existing SKU if provided
    if (dto.sku) {
      const existingProduct = await this.productRepository.findBySku(dto.sku);
      if (existingProduct) {
        throw new Error(`Product with SKU ${dto.sku} already exists`);
      }
    }

    // Check for existing slug if provided
    if (dto.slug) {
      const existingSlug = await this.productRepository.findBySlug(dto.slug);
      if (existingSlug) {
        throw new Error(`Product with slug ${dto.slug} already exists`);
      }
    }

    // For now, create a simple product entity
    // TODO: Implement proper aggregate creation
    const product = new Product(
      '', // id will be generated by DB
      dto.name,
      dto.description,
      dto.sku || '',
      new Money(dto.price, dto.currency || 'EUR'),
      dto.artisanId,
      dto.categoryId,
      dto.slug || '',
      dto.originalPrice ? new Money(dto.originalPrice, dto.currency || 'EUR') : undefined,
      dto.isHandmade || false,
      dto.isCustomizable || false,
      dto.isDigital || false,
      dto.requiresShipping || false,
      dto.keywords || [],
      dto.keywords || [],
      dto.metaTitle || undefined,
      dto.metaDescription || undefined,
      false // featured
    );

    // Save to repository
    await this.productRepository.save(product);

    // Publish domain events
    await this.publishDomainEvents(product);

    return product;
  }

  async updateProduct(dto: UpdateProductDTO): Promise<Product> {
    const product = await this.productRepository.findById(dto.id);
    if (!product) {
      throw new Error(`Product with id ${dto.id} not found`);
    }

    // For now, just update the product directly
    // TODO: Implement proper domain update methods
    if (dto.name) (product as any).name = dto.name;
    if (dto.description) (product as any).description = dto.description;
    if (dto.price !== undefined)
      (product as any)._price = new Money(dto.price, product.price.currency);
    if (dto.originalPrice !== undefined)
      (product as any)._originalPrice = new Money(dto.originalPrice, product.price.currency);
    if (dto.keywords) (product as any).keywords = dto.keywords;
    if (dto.metaTitle !== undefined) (product as any).metaTitle = dto.metaTitle;
    if (dto.metaDescription !== undefined) (product as any).metaDescription = dto.metaDescription;

    await this.productRepository.update(product);
    await this.publishDomainEvents(product);

    return product;
  }

  async findById(id: string): Promise<Product | null> {
    return await this.productRepository.findById(id);
  }

  async findBySku(sku: string): Promise<Product | null> {
    return await this.productRepository.findBySku(sku);
  }

  async findBySlug(slug: string): Promise<Product | null> {
    return await this.productRepository.findBySlug(slug);
  }

  async deleteProduct(id: string): Promise<void> {
    const product = await this.productRepository.findById(id);
    if (!product) {
      throw new Error(`Product with id ${id} not found`);
    }

    await this.productRepository.delete(id);
  }

  // ========================================
  // STOCK MANAGEMENT METHODS
  // ========================================

  async addStockToProduct(productId: string, quantity: number): Promise<Product> {
    const product = await this.productRepository.findById(productId);
    if (!product) {
      throw new Error(`Product with id ${productId} not found`);
    }

    // TODO: Implement stock management
    // product.addStock(quantity);
    await this.productRepository.update(product);
    await this.publishDomainEvents(product);

    return product;
  }

  async removeStockFromProduct(productId: string, quantity: number): Promise<Product> {
    const product = await this.productRepository.findById(productId);
    if (!product) {
      throw new Error(`Product with id ${productId} not found`);
    }

    // TODO: Implement stock management
    // product.removeStock(quantity);
    await this.productRepository.update(product);
    await this.publishDomainEvents(product);

    return product;
  }

  async getProductStock(
    productId: string
  ): Promise<{ stock: number; isInStock: boolean; isLowStock: boolean }> {
    const product = await this.productRepository.findById(productId);
    if (!product) {
      throw new Error(`Product with id ${productId} not found`);
    }

    // TODO: Implement stock management
    return {
      stock: 0, // product.stock,
      isInStock: true, // product.isInStock(),
      isLowStock: false, // product.isLowStock(),
    };
  }

  // ========================================
  // PRODUCT STATUS MANAGEMENT
  // ========================================

  async publishProduct(id: string): Promise<Product> {
    const product = await this.productRepository.findById(id);
    if (!product) {
      throw new Error(`Product with id ${id} not found`);
    }

    // TODO: Add domain method to change status to ACTIVE
    // For now, we'll handle it through reconstruction or direct update

    await this.productRepository.update(product);
    await this.publishDomainEvents(product);

    return product;
  }

  async archiveProduct(id: string): Promise<Product> {
    const product = await this.productRepository.findById(id);
    if (!product) {
      throw new Error(`Product with id ${id} not found`);
    }

    // TODO: Add domain method to change status to INACTIVE
    // For now, we'll handle it through reconstruction or direct update

    await this.productRepository.update(product);
    await this.publishDomainEvents(product);

    return product;
  }

  private async publishDomainEvents(product: Product): Promise<void> {
    // For now, just publish a simple event
    // In a full implementation, this would collect all domain events
    await this.eventBus.publish(EventSubjects.PRODUCT_CREATED, {
      productId: product.id,
      name: product.name,
      sku: product.sku,
      price: product.price,
    });
  }
}
